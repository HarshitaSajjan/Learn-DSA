two pointer / sliding window
it si not typical algo but a constructive algo



1. Constant Window
    like given arr u need to find max/min sum of consecutively k elementrs

    while(r<n-1){
        sum= sum-arr[l]
        l++;
        r++;
        saum=sum+arr[r];

        maxsum=max(maxsum, sum);
    }


2. Longest subarray/substring where<condition>
        like longest subarray with sum <=k

        brute force- to generate all subarrays and check, a singe ele,ent and all subarrays witht hat and so on
        better 
        optimal
    brute force
    maxlen=0;
    for(i=0->n-1){
        for(n=i->n-1){
            sum=sum+arr[j]
            if(sum<=k)
            maxlen=max(maxlen, j-i+1);
            else if (sum>k) break;
        }
    }
    print maxlen;



    1. exapnd window(right edge)
    2. shrink window(left edge)

    l=0, r=0, sum=0, maxlen=0
    while(r<n){ // dont write while loop, simply travese
        sum=sum+arr[r];

        (sum>k){
            summ=summ-arr[l];
            l=l+1
        }
        if(sum<=k)
            maxlen=max(maxlen, r-l+1)

        r=r+1;
    }
    print(maxlen);



3. No of subarrays where <conditions>   
        using pattern 2
        divide into 2 partss
            x=no of subarrays where sum<=k
            y=and sum<=k-1
            and then x-y


4. shortest/Minimum window <condition>
        l and r ->valid window shrink window
        shortest valid window store it
